## Variant 3 – Shared “Buffer Manager” object

- Create a separate `BufferManager` class (could live in parser module).
- Network calls:

 `bufferManager.feed(fd, raw_chunk)` and asks 

`std::vectorstd::string messages = bufferManager.extractMessages(fd);`

- Parser gets already split messages (strings) from `BufferManager`, Logic gets parsed `IRCMessage`.
- Responsibility is explicit and testable; Network and Parser both depend on the same buffer API.

```jsx
// BufferManager (can live in parser/ or utils/)
class BufferManager {
    std::map<int, std::string> _buffers; // fd -> partial data

public:
    void feed(int fd, const std::string& chunk) {
        _buffers[fd].append(chunk);
    }

    std::vector<std::string> extractMessages(int fd) {
        std::vector<std::string> msgs;
        std::string& b = _buffers[fd];

        size_t pos;
        while ((pos = b.find("\r\n")) != std::string::npos) {
            msgs.push_back(b.substr(0, pos));
            b.erase(0, pos + 2);
        }
        return msgs;
    }

    void clear(int fd) {
        _buffers.erase(fd);
    }
};

```

```jsx
// In Server (Network Layer, Person 1)
class Server {
    BufferManager _bufferManager;
    Parser       _parser;

public:
    void onReadable(int fd) {
        char buf[4096];
        ssize_t n = recv(fd, buf, sizeof(buf), 0);
        if (n <= 0) {
            _bufferManager.clear(fd);
            // handle disconnect
            return;
        }

        _bufferManager.feed(fd, std::string(buf, n));
        std::vector<std::string> msgs = _bufferManager.extractMessages(fd);

        for (size_t i = 0; i < msgs.size(); ++i)
            _parser.handleRawMessage(fd, msgs[i]);
    }
};

```

```jsx
// In Parser (Person 2)
class Parser {
public:
    void handleRawMessage(int fd, const std::string& raw) {
        IRCMessage msg = parseIRCMessage(raw);
        logic.handleMessage(fd, msg);
    }
};

```

***Here the `Client` class can also be designed in two ways, depending on whether the buffer is logically owned by the parser side or kept completely external.***

```jsx
// Parser-side buffer ownership
class Client {
public:
    int getFd() const;
    std::string getNickname() const;
    std::string getUsername() const;
    bool isRegistered() const;
    bool isOperator(const std::string& channel) const;
    
    void appendToBuffer(const std::string& data);
    std::string getBuffer();
    
    // Additional methods each person may add
};

```

```jsx
// External buffer ownership (Network or BufferManager)
class Client {
public:
    int getFd() const;
    std::string getNickname() const;
    std::string getUsername() const;
    bool isRegistered() const;
    bool isOperator(const std::string& channel) const;

    // No receive buffer methods in this model:
    // Network or a separate BufferManager keeps std::map<int, std::string> for buffers
};

```

Pros (short):

- Clear separation: Network = sockets, BufferManager = stream → messages, Parser = messages → IRC commands.
- Easier to test each piece independently.
- Elegant:
Network → BufferManager → Parser → Logic, where each layer does one clear thing.

Cons (short):

- One extra abstraction and class to design.
- Team must clearly agree who creates/owns `BufferManager` and how it is accessed.

*it only changes who exactly owns the accumulation of lines up to **\r\n***
