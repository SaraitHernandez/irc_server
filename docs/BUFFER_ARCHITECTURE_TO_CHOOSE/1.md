## **Network ↔ Parser Data Flow**


## Variant 1 – Parser owns buffers

- Network calls something like `parser.onData(fd, raw_chunk)`.
- Parser keeps `std::map<int, std::string>` of buffers and extracts complete IRC messages.
- Network is only responsible for sockets and `send()`/`recv()`.

***Implementation***

```jsx
// In Client class (owned by Logic, Person 3)
class Client {
    std::string receiveBuffer;  // Parser manages this content
public:
    void appendToBuffer(const std::string& data);
    std::string getBuffer();
    // ... other methods
};

```

```jsx
class Client {
public:
    int getFd() const;
    std::string getNickname() const;
    std::string getUsername() const;
    bool isRegistered() const;
    bool isOperator(const std::string& channel) const;
    
    void appendToBuffer(const std::string& data);
    std::string getBuffer();
    
    // Additional methods each person may add
}; 
```

**Pros:**

- Keeps the Network layer simple and focused on sockets and I/O only (accept, recv, send).
- Buffering logic lives close to parsing logic, which understands IRC message boundaries (**`\r\n`**).
- Easier to adjust parsing and buffering rules without touching low-level network code.
- Fits naturally with a **`Client`** class that already stores per-user state (nick, registration, etc.).

**Cons:**

- Parser/Logic layer must be aware of low-level details like partial reads and TCP streaming behavior.
- More back-and-forth design work: Network passes raw data, Parser updates buffers, Logic reads from them.
- Harder to fully isolate and unit-test the Parser without also simulating buffer state per client.

---