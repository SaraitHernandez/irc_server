## **Network ↔ Parser Data Flow**

## Variant 2 – Network owns buffers

- Network layer keeps `std::map<int, std::string> clientBuffers`.
- On `recv()`, it appends to `clientBuffers[fd]`.
- When it finds `\r\n`, it extracts a full line and calls `parser.parseMessage(fd, line)`.
- Parser works only with complete IRC lines, no buffering logic inside.

```jsx
// In Server (Network Layer, Person 1)
class Server {
    std::map<int, std::string> _buffers; // fd -> partial data

public:
    void onReadable(int fd) {
        char buf[4096];
        ssize_t n = recv(fd, buf, sizeof(buf), 0);
        if (n <= 0) {
            // handle disconnect / error
            return;
        }

        _buffers[fd].append(buf, n);

        std::string& b = _buffers[fd];
        size_t pos;
        while ((pos = b.find("\r\n")) != std::string::npos) {
            std::string line = b.substr(0, pos);      // one full IRC line
            b.erase(0, pos + 2);                      // remove processed part

            parser.parseLine(fd, line);               // Parser Layer call
        }
    }
};

```

```jsx
// In Parser (Person 2)
class Parser {
public:
    void parseLine(int fd, const std::string& line) {
        // line is already complete, no buffering needed here
        IRCMessage msg = parseIRCMessage(line);
        logic.handleMessage(fd, msg); // Person 3
    }
};

```

```jsx
class Client {
public:
    int getFd() const;
    std::string getNickname() const;
    std::string getUsername() const;
    bool isRegistered() const;
    bool isOperator(const std::string& channel) const;

    // No receive buffer methods here in this model
    // Network keeps std::map<int, std::string> for buffers
};

```

Pros (short):

- Parser is simpler (pure parsing, no buffering).
- All I/O logic (including buffering) is in one place: Network.

Cons (short):

- Network layer becomes more complex and less “dumb transport”.
- Parser cannot easily change buffering strategy without touching Network.

---